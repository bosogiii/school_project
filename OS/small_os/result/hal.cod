; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\develop\MyoskOS\hal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ ; `string'
;	COMDAT ??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_H'
	DB	'ardDrive() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp'
	DB	'_IRQ_MathCoprocessor() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_Mouse'
	DB	'() ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_VGA() ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_C'
	DB	'MOSClock() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_LPT1()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_LPT2()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_COM1()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_COM2()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ DB 'Hal'
	DB	'p_IRQ_ReqFromSlave8259() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_EC'
	DB	'T_MachineCheck() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_AlignmentCheck() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_FloatingPointError() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_P'
	DB	'ageFault() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ DB 'Ha'
	DB	'lp_ECT_GeneralProtection() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_StackException() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ DB 'Ha'
	DB	'lp_ECT_SegmentNotPresent() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_'
	DB	'InvalidTSS() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_CoprocessorOverrun() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_DeviceNotAvailable() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_E'
	DB	'CT_InvaildOpcode() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_BOUN'
	DB	'DS() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_INTO()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_'
	DB	'Breakpoint() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_NMI() ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_DebugException() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?msg@?1??Halp_ECT_DivideByZero@@9@9 DD FLAT:??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_DivideByZero'::`2'::msg
?msg@?1??Halp_ECT_DebugException@@9@9 DD FLAT:??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_DebugException'::`2'::msg
?msg@?1??Halp_ECT_NMI@@9@9 DD FLAT:??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_NMI'::`2'::msg
?msg@?1??Halp_ECT_Breakpoint@@9@9 DD FLAT:??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_Breakpoint'::`2'::msg
?msg@?1??Halp_ECT_INTO@@9@9 DD FLAT:??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_INTO'::`2'::msg
?msg@?1??Halp_ECT_BOUNDS@@9@9 DD FLAT:??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_BOUNDS'::`2'::msg
?msg@?1??Halp_ECT_InvaildOpcode@@9@9 DD FLAT:??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_InvaildOpcode'::`2'::msg
?msg@?1??Halp_ECT_DeviceNotAvailable@@9@9 DD FLAT:??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_DeviceNotAvailable'::`2'::msg
?msg@?1??Halp_ECT_CoprocessorOverrun@@9@9 DD FLAT:??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_CoprocessorOverrun'::`2'::msg
?msg@?1??Halp_ECT_InvalidTSS@@9@9 DD FLAT:??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_InvalidTSS'::`2'::msg
?msg@?1??Halp_ECT_SegmentNotPresent@@9@9 DD FLAT:??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_SegmentNotPresent'::`2'::msg
?msg@?1??Halp_ECT_StackException@@9@9 DD FLAT:??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_StackException'::`2'::msg
?msg@?1??Halp_ECT_GeneralProtection@@9@9 DD FLAT:??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_GeneralProtection'::`2'::msg
?msg@?1??Halp_ECT_PageFault@@9@9 DD FLAT:??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_PageFault'::`2'::msg
?msg@?1??Halp_ECT_FloatingPointError@@9@9 DD FLAT:??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_FloatingPointError'::`2'::msg
?msg@?1??Halp_ECT_AlignmentCheck@@9@9 DD FLAT:??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_AlignmentCheck'::`2'::msg
?msg@?1??Halp_ECT_MachineCheck@@9@9 DD FLAT:??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_MachineCheck'::`2'::msg
?msg@?1??Halp_IRQ_ReqFromSlave8259@@9@9 DD FLAT:??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_ReqFromSlave8259'::`2'::msg
?msg@?1??Halp_IRQ_COM2@@9@9 DD FLAT:??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_COM2'::`2'::msg
?msg@?1??Halp_IRQ_COM1@@9@9 DD FLAT:??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_COM1'::`2'::msg
?msg@?1??Halp_IRQ_LPT2@@9@9 DD FLAT:??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_LPT2'::`2'::msg
?msg@?1??Halp_IRQ_LPT1@@9@9 DD FLAT:??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_LPT1'::`2'::msg
?msg@?1??Halp_IRQ_CMOSClock@@9@9 DD FLAT:??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_CMOSClock'::`2'::msg
?msg@?1??Halp_IRQ_VGA@@9@9 DD FLAT:??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_VGA'::`2'::msg
?msg@?1??Halp_IRQ_Mouse@@9@9 DD FLAT:??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_Mouse'::`2'::msg
?msg@?1??Halp_IRQ_MathCoprocessor@@9@9 DD FLAT:??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_MathCoprocessor'::`2'::msg
?msg@?1??Halp_IRQ_HardDrive@@9@9 DD FLAT:??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_HardDrive'::`2'::msg
	ORG $+4
_m_IntHandlers DB 00H
	DD	FLAT:_Halp_ECT_DivideByZero
	DW	08e00H
	DB	01H
	DD	FLAT:_Halp_ECT_DebugException
	DW	08e00H
	DB	02H
	DD	FLAT:_Halp_ECT_NMI
	DW	08e00H
	DB	03H
	DD	FLAT:_Halp_ECT_Breakpoint
	DW	08e00H
	DB	04H
	DD	FLAT:_Halp_ECT_INTO
	DW	08e00H
	DB	05H
	DD	FLAT:_Halp_ECT_BOUNDS
	DW	08e00H
	DB	06H
	DD	FLAT:_Halp_ECT_InvaildOpcode
	DW	08e00H
	DB	07H
	DD	FLAT:_Halp_ECT_DeviceNotAvailable
	DW	08e00H
	DB	08H
	DD	FLAT:_Halp_ECT_DoubleFault
	DW	08e00H
	DB	09H
	DD	FLAT:_Halp_ECT_CoprocessorOverrun
	DW	08e00H
	DB	0aH
	DD	FLAT:_Halp_ECT_InvalidTSS
	DW	08e00H
	DB	0bH
	DD	FLAT:_Halp_ECT_SegmentNotPresent
	DW	08e00H
	DB	0cH
	DD	FLAT:_Halp_ECT_StackException
	DW	08e00H
	DB	0dH
	DD	FLAT:_Halp_ECT_GeneralProtection
	DW	08e00H
	DB	0eH
	DD	FLAT:_Halp_ECT_PageFault
	DW	08e00H
	DB	010H
	DD	FLAT:_Halp_ECT_FloatingPointError
	DW	08e00H
	DB	011H
	DD	FLAT:_Halp_ECT_AlignmentCheck
	DW	08e00H
	DB	012H
	DD	FLAT:_Halp_ECT_MachineCheck
	DW	08e00H
	DB	021H
	DD	FLAT:_Halp_IRQ_Keyboard
	DW	08e00H
	DB	022H
	DD	FLAT:_Halp_IRQ_ReqFromSlave8259
	DW	08e00H
	DB	023H
	DD	FLAT:_Halp_IRQ_COM2
	DW	08e00H
	DB	024H
	DD	FLAT:_Halp_IRQ_COM1
	DW	08e00H
	DB	025H
	DD	FLAT:_Halp_IRQ_LPT2
	DW	08e00H
	DB	026H
	DD	FLAT:_Halp_IRQ_FloppyDisk
	DW	08e00H
	DB	027H
	DD	FLAT:_Halp_IRQ_LPT1
	DW	08e00H
	DB	028H
	DD	FLAT:_Halp_IRQ_CMOSClock
	DW	08e00H
	DB	029H
	DD	FLAT:_Halp_IRQ_VGA
	DW	08e00H
	DB	02cH
	DD	FLAT:_Halp_IRQ_Mouse
	DW	08e00H
	DB	02dH
	DD	FLAT:_Halp_IRQ_MathCoprocessor
	DW	08e00H
	DB	02eH
	DD	FLAT:_Halp_IRQ_HardDrive
	DW	08e00H
	DB	00H
	DD	00H
	DW	00H
_DATA	ENDS
;	COMDAT ??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_EC'
	DB	'T_DivideByZero() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@ ; `string'
PUBLIC	_HalInitializeHal
EXTRN	_CrtPrintf:PROC
;	COMDAT ??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@
; File c:\develop\myoskos\hal.c
CONST	SEGMENT
??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@ DB 'HalpIniti'
	DB	'alizeProcessor() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HalInitializeHal
_TEXT	SEGMENT
_HalInitializeHal PROC					; COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29   : 	//실질적인 하드웨어 초기화 함수 호출
; 30   : 	if(!HalpInitializeProcessor()) {

  00009	e8 00 00 00 00	 call	 _HalpInitializeProcessor
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN1@HalInitial

; 31   : 		DbgPrint("HalpInitializeProcessor() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 32   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 05		 jmp	 SHORT $LN2@HalInitial
$LN1@HalInitial:

; 33   : 	}
; 34   : 
; 35   : 	return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1
$LN2@HalInitial:

; 36   : 
; 37   : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_HalInitializeHal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@ ; `string'
PUBLIC	??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@ ; `string'
PUBLIC	??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@ ; `string'
PUBLIC	??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@ ; `string'
;	COMDAT ??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@
CONST	SEGMENT
??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@ DB 'Interru'
	DB	'pt Service is installed!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@ DB 'HalpStar'
	DB	'tIntService() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@ DB 'Sy'
	DB	'stemTimer is initialized!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@
CONST	SEGMENT
??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@ DB 'HalpIni'
	DB	'tSysTimer() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@ DB 'PIC is success'
	DB	'!!', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@
CONST	SEGMENT
??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@ DB 'HalpIn'
	DB	'itPIC() returned an error.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@ DB 'A20 line'
	DB	' is success!!', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@
CONST	SEGMENT
??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@ DB 'HalpEna'
	DB	'bleA20() returned an error.', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HalpInitializeProcessor
_TEXT	SEGMENT
_HalpInitializeProcessor PROC				; COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 42   : 	//A20 Line 활성화 함수
; 43   : 	if(!HalpEnableA20()) {

  00009	e8 00 00 00 00	 call	 _HalpEnableA20
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN4@HalpInitia

; 44   : 		DbgPrint("HalpEnableA20() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 45   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 8c 00 00 00	 jmp	 $LN5@HalpInitia
$LN4@HalpInitia:

; 46   : 	}
; 47   : 	DbgPrint("A20 line is success!!\r\n");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@
  0002b	e8 00 00 00 00	 call	 _CrtPrintf
  00030	83 c4 04	 add	 esp, 4

; 48   : 
; 49   : 	//PIC 초기화 함수
; 50   : 	if(!HalpInitPIC()) {

  00033	e8 00 00 00 00	 call	 _HalpInitPIC
  00038	85 c0		 test	 eax, eax
  0003a	75 11		 jne	 SHORT $LN3@HalpInitia

; 51   : 		DbgPrint("HalpInitPIC() returned an error.\r\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@
  00041	e8 00 00 00 00	 call	 _CrtPrintf
  00046	83 c4 04	 add	 esp, 4

; 52   : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 65		 jmp	 SHORT $LN5@HalpInitia
$LN3@HalpInitia:

; 53   : 	}
; 54   : 	DbgPrint("PIC is success!!\r\n");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@
  00052	e8 00 00 00 00	 call	 _CrtPrintf
  00057	83 c4 04	 add	 esp, 4

; 55   : 
; 56   : 	//TIMER 초기화 함수
; 57   : 	if(!HalpInitSysTimer(TIMEOUT_PER_SECOND)) {

  0005a	6a 32		 push	 50			; 00000032H
  0005c	e8 00 00 00 00	 call	 _HalpInitSysTimer
  00061	83 c4 04	 add	 esp, 4
  00064	85 c0		 test	 eax, eax
  00066	75 11		 jne	 SHORT $LN2@HalpInitia

; 58   : 		DbgPrint("HalpInitSysTimer() returned an error.\r\n");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@
  0006d	e8 00 00 00 00	 call	 _CrtPrintf
  00072	83 c4 04	 add	 esp, 4

; 59   : 		return FALSE;

  00075	33 c0		 xor	 eax, eax
  00077	eb 39		 jmp	 SHORT $LN5@HalpInitia
$LN2@HalpInitia:

; 60   : 	}
; 61   : 	DbgPrint("SystemTimer is initialized!!\r\n");

  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@
  0007e	e8 00 00 00 00	 call	 _CrtPrintf
  00083	83 c4 04	 add	 esp, 4

; 62   : 
; 63   : 	//INTERRUPT 초기화 함수 
; 64   : 	if(!HalpStartIntService()) {

  00086	e8 00 00 00 00	 call	 _HalpStartIntService
  0008b	85 c0		 test	 eax, eax
  0008d	75 11		 jne	 SHORT $LN1@HalpInitia

; 65   : 		DbgPrint("HalpStartIntService() returned an error.\r\n");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@
  00094	e8 00 00 00 00	 call	 _CrtPrintf
  00099	83 c4 04	 add	 esp, 4

; 66   : 		return FALSE;

  0009c	33 c0		 xor	 eax, eax
  0009e	eb 12		 jmp	 SHORT $LN5@HalpInitia
$LN1@HalpInitia:

; 67   : 	}
; 68   : 	DbgPrint("Interrupt Service is installed!!\r\n");

  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@
  000a5	e8 00 00 00 00	 call	 _CrtPrintf
  000aa	83 c4 04	 add	 esp, 4

; 69   : 
; 70   : 
; 71   : 	return TRUE;

  000ad	b8 01 00 00 00	 mov	 eax, 1
$LN5@HalpInitia:

; 72   : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_HalpInitializeProcessor ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HalpEnableA20
_TEXT	SEGMENT
_flag$ = -18						; size = 1
_status$ = -17						; size = 1
_test_2_buf$ = -16					; size = 4
_test_2$ = -12						; size = 4
_test_1_buf$ = -8					; size = 4
_test_1$ = -4						; size = 4
_HalpEnableA20 PROC					; COMDAT

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 75   : 	int *test_1 = (int *)0x00000000, test_1_buf;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _test_1$[ebp], 0

; 76   : 	int *test_2 = (int *)0x00100000, test_2_buf;

  00010	c7 45 f4 00 00
	10 00		 mov	 DWORD PTR _test_2$[ebp], 1048576 ; 00100000H
$LN16@HalpEnable:

; 77   : 	UCHAR status, flag;
; 78   : 
; 79   : 	//Status Register(0x64)를 읽어서 입력 버퍼에 데이터가 없을 때까지 대기.
; 80   : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  00017	6a 64		 push	 100			; 00000064H
  00019	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  0001e	83 c4 04	 add	 esp, 4
  00021	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 81   : 	while( status & 0x02 );

  00024	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  00028	83 e0 02	 and	 eax, 2
  0002b	75 ea		 jne	 SHORT $LN16@HalpEnable

; 82   : 	//Control Register에 데이터를 쓰는 과정
; 83   : 	//output port에서 데이터를 읽어서 출력 버퍼(0x60)에 데이터를 저장하라는 명령.
; 84   : 		WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd0);

  0002d	68 d0 00 00 00	 push	 208			; 000000d0H
  00032	6a 64		 push	 100			; 00000064H
  00034	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00039	83 c4 08	 add	 esp, 8
$LN13@HalpEnable:

; 85   : 
; 86   : 	//Status Register(Ox64)를 읽어서 출력 버퍼(Ox60)에 데이터가 들어올때 까지 대기.
; 87   : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  0003c	6a 64		 push	 100			; 00000064H
  0003e	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00043	83 c4 04	 add	 esp, 4
  00046	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 88   : 	while( !(status&0x01) );

  00049	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0004d	83 e0 01	 and	 eax, 1
  00050	74 ea		 je	 SHORT $LN13@HalpEnable

; 89   : 	//출력 버퍼(Ox60)에서 데이터를 읽은 후에 A20 GATE(두 번째 비트)활성화 	
; 90   : 	flag = READ_PORT_UCHAR((PUCHAR)0x60);

  00052	6a 60		 push	 96			; 00000060H
  00054	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00059	83 c4 04	 add	 esp, 4
  0005c	88 45 ee	 mov	 BYTE PTR _flag$[ebp], al

; 91   : 	flag |= 0x02; // A20 line 활성화

  0005f	0f b6 45 ee	 movzx	 eax, BYTE PTR _flag$[ebp]
  00063	83 c8 02	 or	 eax, 2
  00066	88 45 ee	 mov	 BYTE PTR _flag$[ebp], al
$LN10@HalpEnable:

; 92   : 
; 93   : 	//flag값을 Register에 써넣어 A20 활성화
; 94   : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  00069	6a 64		 push	 100			; 00000064H
  0006b	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00070	83 c4 04	 add	 esp, 4
  00073	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 95   : 	while( status & 0x02 );

  00076	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0007a	83 e0 02	 and	 eax, 2
  0007d	75 ea		 jne	 SHORT $LN10@HalpEnable

; 96   : 	WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd1);

  0007f	68 d1 00 00 00	 push	 209			; 000000d1H
  00084	6a 64		 push	 100			; 00000064H
  00086	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0008b	83 c4 08	 add	 esp, 8
$LN7@HalpEnable:

; 97   : 
; 98   : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); } 

  0008e	6a 64		 push	 100			; 00000064H
  00090	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00095	83 c4 04	 add	 esp, 4
  00098	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 99   : 	while( status & 0x02 );

  0009b	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0009f	83 e0 02	 and	 eax, 2
  000a2	75 ea		 jne	 SHORT $LN7@HalpEnable

; 100  : 	WRITE_PORT_UCHAR((PUCHAR)0x60, flag); 

  000a4	8a 45 ee	 mov	 al, BYTE PTR _flag$[ebp]
  000a7	50		 push	 eax
  000a8	6a 60		 push	 96			; 00000060H
  000aa	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  000af	83 c4 08	 add	 esp, 8
$LN4@HalpEnable:

; 101  : 
; 102  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); } 

  000b2	6a 64		 push	 100			; 00000064H
  000b4	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  000b9	83 c4 04	 add	 esp, 4
  000bc	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 103  : 	while( status & 0x02 );

  000bf	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  000c3	83 e0 02	 and	 eax, 2
  000c6	75 ea		 jne	 SHORT $LN4@HalpEnable

; 104  : 
; 105  : 	//Test A20 line
; 106  : 	test_1_buf = *test_1;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 4d f8	 mov	 DWORD PTR _test_1_buf$[ebp], ecx

; 107  : 	test_2_buf = *test_2;

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	89 4d f0	 mov	 DWORD PTR _test_2_buf$[ebp], ecx

; 108  : 	*test_1 = 0xff00ccaa;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000db	c7 00 aa cc 00
	ff		 mov	 DWORD PTR [eax], -16724822 ; ff00ccaaH

; 109  : 	*test_2 = 0x22cc11dd;

  000e1	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  000e4	c7 00 dd 11 cc
	22		 mov	 DWORD PTR [eax], 583799261 ; 22cc11ddH

; 110  : 	if(*test_1 == *test_2) {

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR _test_2$[ebp]
  000f0	8b 10		 mov	 edx, DWORD PTR [eax]
  000f2	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000f4	75 0c		 jne	 SHORT $LN1@HalpEnable

; 111  : 		*test_1 = test_1_buf;

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _test_1_buf$[ebp]
  000fc	89 08		 mov	 DWORD PTR [eax], ecx

; 112  : 		return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	eb 15		 jmp	 SHORT $LN17@HalpEnable
$LN1@HalpEnable:

; 113  : 	}
; 114  : 	//A20 line이 활성화 되었다면, test_1과 test_2의 값이 달라야 한다.
; 115  : 	*test_1 = test_1_buf;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  00105	8b 4d f8	 mov	 ecx, DWORD PTR _test_1_buf$[ebp]
  00108	89 08		 mov	 DWORD PTR [eax], ecx

; 116  : 	*test_2 = test_2_buf;

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  0010d	8b 4d f0	 mov	 ecx, DWORD PTR _test_2_buf$[ebp]
  00110	89 08		 mov	 DWORD PTR [eax], ecx

; 117  : 
; 118  : 	return TRUE;

  00112	b8 01 00 00 00	 mov	 eax, 1
$LN17@HalpEnable:

; 119  : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
_HalpEnableA20 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalpInitPIC
_TEXT	SEGMENT
_HalpInitPIC PROC					; COMDAT

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 130  : 	// Master PIC
; 131  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x11); //ICW1 : Cascade mode, ICW4 

  00009	6a 11		 push	 17			; 00000011H
  0000b	6a 20		 push	 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00012	83 c4 08	 add	 esp, 8

; 132  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x20); //ICW2 : 인터럽트 시작 값 INT vector 20h 

  00015	6a 20		 push	 32			; 00000020H
  00017	6a 21		 push	 33			; 00000021H
  00019	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0001e	83 c4 08	 add	 esp, 8

; 133  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x04); //ICW3  

  00021	6a 04		 push	 4
  00023	6a 21		 push	 33			; 00000021H
  00025	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002a	83 c4 08	 add	 esp, 8

; 134  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x01); //ICW4 

  0002d	6a 01		 push	 1
  0002f	6a 21		 push	 33			; 00000021H
  00031	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00036	83 c4 08	 add	 esp, 8

; 135  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x00);

  00039	6a 00		 push	 0
  0003b	6a 21		 push	 33			; 00000021H
  0003d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00042	83 c4 08	 add	 esp, 8

; 136  : 
; 137  : 	// Slave PIC 
; 138  : 	WRITE_PORT_UCHAR((PUCHAR)0xa0, 0x11); //ICW1 : Cascade mode, ICW4 

  00045	6a 11		 push	 17			; 00000011H
  00047	68 a0 00 00 00	 push	 160			; 000000a0H
  0004c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00051	83 c4 08	 add	 esp, 8

; 139  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x28); //ICW2 : 인터럽트 시작 값 INT vector 28h 

  00054	6a 28		 push	 40			; 00000028H
  00056	68 a1 00 00 00	 push	 161			; 000000a1H
  0005b	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00060	83 c4 08	 add	 esp, 8

; 140  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x02); //ICW3  

  00063	6a 02		 push	 2
  00065	68 a1 00 00 00	 push	 161			; 000000a1H
  0006a	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0006f	83 c4 08	 add	 esp, 8

; 141  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x01); //ICW4 

  00072	6a 01		 push	 1
  00074	68 a1 00 00 00	 push	 161			; 000000a1H
  00079	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0007e	83 c4 08	 add	 esp, 8

; 142  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x00);

  00081	6a 00		 push	 0
  00083	68 a1 00 00 00	 push	 161			; 000000a1H
  00088	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0008d	83 c4 08	 add	 esp, 8

; 143  : 
; 144  : 	return TRUE;

  00090	b8 01 00 00 00	 mov	 eax, 1

; 145  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_HalpInitPIC ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalpInitSysTimer
_TEXT	SEGMENT
_timeout$ = -4						; size = 2
_timeoutPerSecond$ = 8					; size = 1
_HalpInitSysTimer PROC					; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 149  : 	//새로운 counter 값 입력
; 150  : 	WORD timeout = (WORD)(1193180/timeoutPerSecond);

  00009	0f b6 4d 08	 movzx	 ecx, BYTE PTR _timeoutPerSecond$[ebp]
  0000d	b8 dc 34 12 00	 mov	 eax, 1193180		; 001234dcH
  00012	99		 cdq
  00013	f7 f9		 idiv	 ecx
  00015	66 89 45 fc	 mov	 WORD PTR _timeout$[ebp], ax

; 151  : 
; 152  : 	WRITE_PORT_UCHAR((PUCHAR)0x43, 0x34);

  00019	6a 34		 push	 52			; 00000034H
  0001b	6a 43		 push	 67			; 00000043H
  0001d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00022	83 c4 08	 add	 esp, 8

; 153  : 
; 154  : 	//COUNTER 0 Register의 Low, High byte 값 설정
; 155  : 	WRITE_PORT_UCHAR((PUCHAR)0x40, (UCHAR)(timeout & 0xff));

  00025	0f b7 45 fc	 movzx	 eax, WORD PTR _timeout$[ebp]
  00029	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002e	50		 push	 eax
  0002f	6a 40		 push	 64			; 00000040H
  00031	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00036	83 c4 08	 add	 esp, 8

; 156  : 	WRITE_PORT_UCHAR((PUCHAR)0x40, (UCHAR)(timeout >> 8));

  00039	0f b7 45 fc	 movzx	 eax, WORD PTR _timeout$[ebp]
  0003d	c1 f8 08	 sar	 eax, 8
  00040	50		 push	 eax
  00041	6a 40		 push	 64			; 00000040H
  00043	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00048	83 c4 08	 add	 esp, 8

; 157  : 
; 158  : 	return TRUE;

  0004b	b8 01 00 00 00	 mov	 eax, 1

; 159  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_HalpInitSysTimer ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DivideByZero
_TEXT	SEGMENT
_Halp_ECT_DivideByZero PROC				; COMDAT

; 165  : 	static char *msg = "Halp_ECT_DivideByZero() \r\n";
; 166  : 	_asm {
; 167  : 		pushad

  00000	60		 pushad

; 168  : 
; 169  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DivideByZero@@9@9

; 170  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 171  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 172  : 
; 173  : 		popad

  0000f	61		 popad

; 174  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DivideByZero ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DebugException
_TEXT	SEGMENT
_Halp_ECT_DebugException PROC				; COMDAT

; 180  : 	static char *msg = "Halp_ECT_DebugException() \r\n";
; 181  : 	_asm {
; 182  : 		pushad

  00000	60		 pushad

; 183  : 
; 184  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DebugException@@9@9

; 185  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 186  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 187  : 
; 188  : 		popad

  0000f	61		 popad

; 189  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DebugException ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_NMI
_TEXT	SEGMENT
_Halp_ECT_NMI PROC					; COMDAT

; 195  : 	static char *msg = "Halp_ECT_NMI() \r\n";
; 196  : 	_asm {
; 197  : 		pushad

  00000	60		 pushad

; 198  : 
; 199  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_NMI@@9@9

; 200  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 201  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 202  : 
; 203  : 		popad

  0000f	61		 popad

; 204  : 		iretd

  00010	cf		 iretd
_Halp_ECT_NMI ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ ; `string'
_BSS	SEGMENT
?dwESP@?1??Halp_ECT_Breakpoint@@9@9 DD 01H DUP (?)	; `Halp_ECT_Breakpoint'::`2'::dwESP
_BSS	ENDS
;	COMDAT ??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ DB 'b'
	DB	'p, #1:0x%x, #2:0x%x, #3:0x%x ', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Halp_ECT_Breakpoint
_TEXT	SEGMENT
_Halp_ECT_Breakpoint PROC				; COMDAT

; 210  : 	static char *msg = "Halp_ECT_Breakpoint() \r\n";
; 211  : 	static int dwESP;
; 212  : 	_asm {
; 213  : 		cli

  00000	fa		 cli

; 214  : 		mov	dwESP, esp

  00001	89 25 00 00 00
	00		 mov	 DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9, esp

; 215  : 		pushad

  00007	60		 pushad

; 216  : 	}
; 217  : 
; 218  : 	DbgPrint("bp, #1:0x%x, #2:0x%x, #3:0x%x \r\n", *((int *)dwESP), *((int *)dwESP+1), *((int *)dwESP+2));

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  0000d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00010	51		 push	 ecx
  00011	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  00017	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001a	50		 push	 eax
  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	52		 push	 edx
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
  00029	e8 00 00 00 00	 call	 _CrtPrintf
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@Halp_ECT_B:

; 219  : 	while(1) ;

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	74 02		 je	 SHORT $LN1@Halp_ECT_B
  0003a	eb f5		 jmp	 SHORT $LN2@Halp_ECT_B
$LN1@Halp_ECT_B:

; 220  : 
; 221  : 	_asm {
; 222  : 		popad

  0003c	61		 popad

; 223  : 		iretd

  0003d	cf		 iretd
_Halp_ECT_Breakpoint ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_INTO
_TEXT	SEGMENT
_Halp_ECT_INTO PROC					; COMDAT

; 229  : 	static char *msg = "Halp_ECT_INTO() \r\n";
; 230  : 	_asm {
; 231  : 		pushad

  00000	60		 pushad

; 232  : 
; 233  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_INTO@@9@9

; 234  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 235  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 236  : 
; 237  : 		popad

  0000f	61		 popad

; 238  : 		iretd

  00010	cf		 iretd
_Halp_ECT_INTO ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_BOUNDS
_TEXT	SEGMENT
_Halp_ECT_BOUNDS PROC					; COMDAT

; 244  : 	static char *msg = "Halp_ECT_BOUNDS() \r\n";
; 245  : 	_asm {
; 246  : 		pushad

  00000	60		 pushad

; 247  : 
; 248  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_BOUNDS@@9@9

; 249  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 250  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 251  : 
; 252  : 		popad

  0000f	61		 popad

; 253  : 		iretd

  00010	cf		 iretd
_Halp_ECT_BOUNDS ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_InvaildOpcode
_TEXT	SEGMENT
_Halp_ECT_InvaildOpcode PROC				; COMDAT

; 259  : 	static char *msg = "Halp_ECT_InvaildOpcode() \r\n";
; 260  : 	_asm {
; 261  : 		pushad

  00000	60		 pushad

; 262  : 
; 263  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_InvaildOpcode@@9@9

; 264  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 265  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4
$infinate$859:

; 266  : 
; 267  : infinate:
; 268  : 		jmp		infinate

  0000f	eb fe		 jmp	 SHORT $infinate$859

; 269  : 
; 270  : 		popad

  00011	61		 popad

; 271  : 		iretd

  00012	cf		 iretd
_Halp_ECT_InvaildOpcode ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DeviceNotAvailable
_TEXT	SEGMENT
_Halp_ECT_DeviceNotAvailable PROC			; COMDAT

; 277  : 	static char *msg = "Halp_ECT_DeviceNotAvailable() \r\n";
; 278  : 	_asm {
; 279  : 		pushad

  00000	60		 pushad

; 280  : 
; 281  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DeviceNotAvailable@@9@9

; 282  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 283  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 284  : 
; 285  : 		popad

  0000f	61		 popad

; 286  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DeviceNotAvailable ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DoubleFault
_TEXT	SEGMENT
_Halp_ECT_DoubleFault PROC				; COMDAT

; 292  : 	_asm {
; 293  : 		mov		ebx, 0b8000h

  00000	bb 00 80 0b 00	 mov	 ebx, 753664		; 000b8000H

; 294  : 		mov		ecx, 80*25

  00005	b9 d0 07 00 00	 mov	 ecx, 2000		; 000007d0H
$fault_loop$869:

; 295  : 
; 296  : fault_loop:
; 297  : 		mov		byte ptr [ebx], '#'

  0000a	c6 03 23	 mov	 BYTE PTR [ebx], 35	; 00000023H

; 298  : 		mov		byte ptr [ebx+1], 7

  0000d	c6 43 01 07	 mov	 BYTE PTR [ebx+1], 7

; 299  : 		add		ebx, 2

  00011	83 c3 02	 add	 ebx, 2

; 300  : 		loop	fault_loop

  00014	e2 f4		 loop	 $fault_loop$869
$infinate$870:

; 301  : 
; 302  : infinate:
; 303  : 		jmp		infinate

  00016	eb fe		 jmp	 SHORT $infinate$870
_Halp_ECT_DoubleFault ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_CoprocessorOverrun
_TEXT	SEGMENT
_Halp_ECT_CoprocessorOverrun PROC			; COMDAT

; 309  : 	static char *msg = "Halp_ECT_CoprocessorOverrun() \r\n";
; 310  : 	_asm {
; 311  : 		pushad

  00000	60		 pushad

; 312  : 
; 313  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_CoprocessorOverrun@@9@9

; 314  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 315  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 316  : 
; 317  : 		popad

  0000f	61		 popad

; 318  : 		iretd

  00010	cf		 iretd
_Halp_ECT_CoprocessorOverrun ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_InvalidTSS
_TEXT	SEGMENT
_Halp_ECT_InvalidTSS PROC				; COMDAT

; 324  : 	static char *msg = "Halp_ECT_InvalidTSS() \r\n";
; 325  : 	_asm {
; 326  : 		pushad

  00000	60		 pushad

; 327  : 
; 328  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_InvalidTSS@@9@9

; 329  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 330  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 331  : 
; 332  : 		popad

  0000f	61		 popad

; 333  : 		iretd

  00010	cf		 iretd
_Halp_ECT_InvalidTSS ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_SegmentNotPresent
_TEXT	SEGMENT
_Halp_ECT_SegmentNotPresent PROC			; COMDAT

; 339  : 	static char *msg = "Halp_ECT_SegmentNotPresent() \r\n";
; 340  : 	_asm {
; 341  : 		pushad

  00000	60		 pushad

; 342  : 
; 343  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_SegmentNotPresent@@9@9

; 344  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 345  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 346  : 
; 347  : 		popad

  0000f	61		 popad

; 348  : 		iretd

  00010	cf		 iretd
_Halp_ECT_SegmentNotPresent ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_StackException
_TEXT	SEGMENT
_Halp_ECT_StackException PROC				; COMDAT

; 354  : 	static char *msg = "Halp_ECT_StackException() \r\n";
; 355  : 	_asm {
; 356  : 		pushad

  00000	60		 pushad

; 357  : 
; 358  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_StackException@@9@9

; 359  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 360  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 361  : 
; 362  : 		popad

  0000f	61		 popad

; 363  : 		iretd

  00010	cf		 iretd
_Halp_ECT_StackException ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ ; `string'
_BSS	SEGMENT
?dwESP@?1??Halp_ECT_GeneralProtection@@9@9 DD 01H DUP (?) ; `Halp_ECT_GeneralProtection'::`2'::dwESP
_BSS	ENDS
;	COMDAT ??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ DB 'g'
	DB	'p, #1:0x%x, #2:0x%x, #3:0x%x ', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Halp_ECT_GeneralProtection
_TEXT	SEGMENT
_Halp_ECT_GeneralProtection PROC			; COMDAT

; 369  : 	static char *msg = "Halp_ECT_GeneralProtection() \r\n";
; 370  : 	static int dwESP;
; 371  : 	_asm {
; 372  : 		mov		dwESP, esp

  00000	89 25 00 00 00
	00		 mov	 DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9, esp

; 373  : 		pushad

  00006	60		 pushad

; 374  : 
; 375  : 		push	msg

  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_GeneralProtection@@9@9

; 376  : 		call	CrtPrintf

  0000d	e8 00 00 00 00	 call	 _CrtPrintf

; 377  : 		add		esp, 4

  00012	83 c4 04	 add	 esp, 4

; 378  : 	}
; 379  : 
; 380  : 	DbgPrint("gp, #1:0x%x, #2:0x%x, #3:0x%x \r\n", *((int *)dwESP+0), *((int *)dwESP+1), *((int *)dwESP+2));

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	51		 push	 ecx
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	50		 push	 eax
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
  00036	e8 00 00 00 00	 call	 _CrtPrintf
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
$infinate$907:

; 381  : 
; 382  : 	_asm {
; 383  : infinate:
; 384  : 		jmp		infinate

  0003e	eb fe		 jmp	 SHORT $infinate$907

; 385  : 
; 386  : 		popad

  00040	61		 popad

; 387  : 		iretd

  00041	cf		 iretd
_Halp_ECT_GeneralProtection ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_PageFault
_TEXT	SEGMENT
_Halp_ECT_PageFault PROC				; COMDAT

; 393  : 	static char *msg = "Halp_ECT_PageFault() \r\n";
; 394  : 	_asm {
; 395  : 		pushad

  00000	60		 pushad

; 396  : 
; 397  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_PageFault@@9@9

; 398  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 399  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 400  : 
; 401  : 		popad

  0000f	61		 popad

; 402  : 		iretd

  00010	cf		 iretd
_Halp_ECT_PageFault ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_FloatingPointError
_TEXT	SEGMENT
_Halp_ECT_FloatingPointError PROC			; COMDAT

; 408  : 	static char *msg = "Halp_ECT_FloatingPointError() \r\n";
; 409  : 	_asm {
; 410  : 		pushad

  00000	60		 pushad

; 411  : 
; 412  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_FloatingPointError@@9@9

; 413  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 414  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 415  : 
; 416  : 		popad

  0000f	61		 popad

; 417  : 		iretd

  00010	cf		 iretd
_Halp_ECT_FloatingPointError ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_AlignmentCheck
_TEXT	SEGMENT
_Halp_ECT_AlignmentCheck PROC				; COMDAT

; 423  : 	static char *msg = "Halp_ECT_AlignmentCheck() \r\n";
; 424  : 	_asm {
; 425  : 		pushad

  00000	60		 pushad

; 426  : 
; 427  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_AlignmentCheck@@9@9

; 428  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 429  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 430  : 
; 431  : 		popad

  0000f	61		 popad

; 432  : 		iretd

  00010	cf		 iretd
_Halp_ECT_AlignmentCheck ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_MachineCheck
_TEXT	SEGMENT
_Halp_ECT_MachineCheck PROC				; COMDAT

; 438  : 	static char *msg = "Halp_ECT_MachineCheck() \r\n";
; 439  : 	_asm {
; 440  : 		pushad

  00000	60		 pushad

; 441  : 
; 442  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_MachineCheck@@9@9

; 443  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 444  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 445  : 
; 446  : 		popad

  0000f	61		 popad

; 447  : 		iretd

  00010	cf		 iretd
_Halp_ECT_MachineCheck ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_Keyboard
_TEXT	SEGMENT
_Halp_IRQ_Keyboard PROC					; COMDAT

; 456  : 	_asm {
; 457  : 		pushad

  00000	60		 pushad

; 458  : 		pushfd

  00001	9c		 pushfd

; 459  : 
; 460  : 		push	ds

  00002	1e		 push	 ds

; 461  : 		push	es

  00003	06		 push	 es

; 462  : 		push	fs

  00004	0f a0		 push	 fs

; 463  : 		push	gs

  00006	0f a8		 push	 gs

; 464  : 
; 465  : 		mov		ax, KERNEL_DS		; change to kernel data segment from user-mode(sometimes) data segment

  00008	66 b8 10 00	 mov	 ax, 16			; 00000010H

; 466  : 		mov		ds, ax

  0000c	66 8e d8	 mov	 ds, ax

; 467  : 		mov		es, ax

  0000f	66 8e c0	 mov	 es, ax

; 468  : 		mov		fs, ax

  00012	66 8e e0	 mov	 fs, ax

; 469  : 		mov		gs, ax

  00015	66 8e e8	 mov	 gs, ax

; 470  : 	} 
; 471  : 
; 472  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x20);

  00018	6a 20		 push	 32			; 00000020H
  0001a	6a 20		 push	 32			; 00000020H
  0001c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00021	83 c4 08	 add	 esp, 8

; 473  : 
; 474  : 	_asm {
; 475  : 		pop		gs

  00024	0f a9		 pop	 gs

; 476  : 		pop		fs

  00026	0f a1		 pop	 fs

; 477  : 		pop		es

  00028	07		 pop	 es

; 478  : 		pop		ds

  00029	1f		 pop	 ds

; 479  : 
; 480  : 		popfd

  0002a	9d		 popfd

; 481  : 		popad

  0002b	61		 popad

; 482  : 		iretd

  0002c	cf		 iretd
_Halp_IRQ_Keyboard ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_ReqFromSlave8259
_TEXT	SEGMENT
_Halp_IRQ_ReqFromSlave8259 PROC				; COMDAT

; 488  : 	static char *msg = "Halp_IRQ_ReqFromSlave8259() \r\n";
; 489  : 	_asm {
; 490  : 		pushad

  00000	60		 pushad

; 491  : 
; 492  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_ReqFromSlave8259@@9@9

; 493  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 494  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 495  : 
; 496  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 497  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 498  : 
; 499  : 		popad

  00013	61		 popad

; 500  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_ReqFromSlave8259 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_COM2
_TEXT	SEGMENT
_Halp_IRQ_COM2 PROC					; COMDAT

; 506  : 	static char *msg = "Halp_IRQ_COM2() \r\n";
; 507  : 	_asm {
; 508  : 		pushad

  00000	60		 pushad

; 509  : 
; 510  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_COM2@@9@9

; 511  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 512  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 513  : 
; 514  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 515  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 516  : 
; 517  : 		popad

  00013	61		 popad

; 518  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_COM2 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_COM1
_TEXT	SEGMENT
_Halp_IRQ_COM1 PROC					; COMDAT

; 524  : 	static char *msg = "Halp_IRQ_COM1() \r\n";
; 525  : 	_asm {
; 526  : 		pushad

  00000	60		 pushad

; 527  : 
; 528  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_COM1@@9@9

; 529  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 530  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 531  : 
; 532  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 533  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 534  : 
; 535  : 		popad

  00013	61		 popad

; 536  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_COM1 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_LPT2
_TEXT	SEGMENT
_Halp_IRQ_LPT2 PROC					; COMDAT

; 542  : 	static char *msg = "Halp_IRQ_LPT2() \r\n";
; 543  : 	_asm {
; 544  : 		pushad

  00000	60		 pushad

; 545  : 
; 546  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_LPT2@@9@9

; 547  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 548  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 549  : 
; 550  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 551  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 552  : 
; 553  : 		popad

  00013	61		 popad

; 554  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_LPT2 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_FloppyDisk
_TEXT	SEGMENT
_Halp_IRQ_FloppyDisk PROC				; COMDAT

; 560  : 
; 561  : 	_asm {
; 562  : 		pushad

  00000	60		 pushad

; 563  : 		pushfd

  00001	9c		 pushfd

; 564  : 
; 565  : 		push	ds

  00002	1e		 push	 ds

; 566  : 		push	es

  00003	06		 push	 es

; 567  : 		push	fs

  00004	0f a0		 push	 fs

; 568  : 		push	gs

  00006	0f a8		 push	 gs

; 569  : 
; 570  : 		mov		ax, KERNEL_DS		; change to kernel data segment from user-mode(sometimes) data segment

  00008	66 b8 10 00	 mov	 ax, 16			; 00000010H

; 571  : 		mov		ds, ax

  0000c	66 8e d8	 mov	 ds, ax

; 572  : 		mov		es, ax

  0000f	66 8e c0	 mov	 es, ax

; 573  : 		mov		fs, ax

  00012	66 8e e0	 mov	 fs, ax

; 574  : 		mov		gs, ax

  00015	66 8e e8	 mov	 gs, ax

; 575  : 	}
; 576  : 
; 577  : 
; 578  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x20);

  00018	6a 20		 push	 32			; 00000020H
  0001a	6a 20		 push	 32			; 00000020H
  0001c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00021	83 c4 08	 add	 esp, 8

; 579  : 
; 580  : 
; 581  : 	_asm {
; 582  : 		pop		gs

  00024	0f a9		 pop	 gs

; 583  : 		pop		fs

  00026	0f a1		 pop	 fs

; 584  : 		pop		es

  00028	07		 pop	 es

; 585  : 		pop		ds

  00029	1f		 pop	 ds

; 586  : 
; 587  : 		popfd

  0002a	9d		 popfd

; 588  : 		popad

  0002b	61		 popad

; 589  : 		iretd

  0002c	cf		 iretd
_Halp_IRQ_FloppyDisk ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_LPT1
_TEXT	SEGMENT
_Halp_IRQ_LPT1 PROC					; COMDAT

; 595  : 	static char *msg = "Halp_IRQ_LPT1() \r\n";
; 596  : 	_asm {
; 597  : 		pushad

  00000	60		 pushad

; 598  : 
; 599  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_LPT1@@9@9

; 600  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 601  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 602  : 
; 603  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 604  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 605  : 
; 606  : 		popad

  00013	61		 popad

; 607  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_LPT1 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_CMOSClock
_TEXT	SEGMENT
_Halp_IRQ_CMOSClock PROC				; COMDAT

; 613  : 	static char *msg = "Halp_IRQ_CMOSClock() \r\n";
; 614  : 	_asm {
; 615  : 		pushad

  00000	60		 pushad

; 616  : 
; 617  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_CMOSClock@@9@9

; 618  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 619  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 620  : 
; 621  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 622  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 623  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 624  : 
; 625  : 		popad

  00015	61		 popad

; 626  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_CMOSClock ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_VGA
_TEXT	SEGMENT
_Halp_IRQ_VGA PROC					; COMDAT

; 632  : 	static char *msg = "Halp_IRQ_VGA() \r\n";
; 633  : 	_asm {
; 634  : 		pushad

  00000	60		 pushad

; 635  : 
; 636  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_VGA@@9@9

; 637  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 638  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 639  : 
; 640  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 641  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 642  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 643  : 
; 644  : 		popad

  00015	61		 popad

; 645  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_VGA ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_Mouse
_TEXT	SEGMENT
_Halp_IRQ_Mouse PROC					; COMDAT

; 651  : 	static char *msg = "Halp_IRQ_Mouse() \r\n";
; 652  : 	_asm {
; 653  : 		pushad

  00000	60		 pushad

; 654  : 
; 655  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_Mouse@@9@9

; 656  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 657  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 658  : 
; 659  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 660  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 661  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 662  : 
; 663  : 		popad

  00015	61		 popad

; 664  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_Mouse ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_MathCoprocessor
_TEXT	SEGMENT
_Halp_IRQ_MathCoprocessor PROC				; COMDAT

; 670  : 	static char *msg = "Halp_IRQ_MathCoprocessor() \r\n";
; 671  : 	_asm {
; 672  : 		pushad

  00000	60		 pushad

; 673  : 
; 674  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_MathCoprocessor@@9@9

; 675  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 676  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 677  : 
; 678  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 679  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 680  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 681  : 
; 682  : 		popad

  00015	61		 popad

; 683  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_MathCoprocessor ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_HardDrive
_TEXT	SEGMENT
_Halp_IRQ_HardDrive PROC				; COMDAT

; 689  : 	static char *msg = "Halp_IRQ_HardDrive() \r\n";
; 690  : 	_asm {
; 691  : 		pushad

  00000	60		 pushad

; 692  : 
; 693  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_HardDrive@@9@9

; 694  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 695  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 696  : 
; 697  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 698  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 699  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 700  : 
; 701  : 		popad

  00015	61		 popad

; 702  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_HardDrive ENDP
_TEXT	ENDS
EXTRN	_HalpEnableInterrupt:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_m_IdtrDesc DF	01H DUP (?)
	ALIGN	8

_m_IdtGate DQ	040H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _HalpStartIntService
_TEXT	SEGMENT
_i$ = -4						; size = 4
_HalpStartIntService PROC				; COMDAT

; 767  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 768  : 	int i;
; 769  : 
; 770  : 	//메모리 초기화
; 771  : 	memset(m_IdtGate, 0, MAX_IDT*sizeof(IDT_GATE));

  00009	68 00 02 00 00	 push	 512			; 00000200H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _m_IdtGate
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 772  : 
; 773  : 	//IDT Table 만들기
; 774  : 	for(i=0; i<MAX_IDT; i++) 

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN4@HalpStartI
$LN3@HalpStartI:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HalpStartI:
  0002f	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00033	0f 8d 9d 00 00
	00		 jge	 $LN2@HalpStartI

; 775  : 	{
; 776  : 		if(m_IntHandlers[i].offset == 0)

  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	6b c0 07	 imul	 eax, 7
  0003f	83 b8 01 00 00
	00 00		 cmp	 DWORD PTR _m_IntHandlers[eax+1], 0
  00046	75 05		 jne	 SHORT $LN1@HalpStartI

; 777  : 			break;

  00048	e9 89 00 00 00	 jmp	 $LN2@HalpStartI
$LN1@HalpStartI:

; 778  : 		
; 779  : 			m_IdtGate[m_IntHandlers[i].number].selector		= KERNEL_CS;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00050	6b c0 07	 imul	 eax, 7
  00053	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_IntHandlers[eax]
  0005a	66 c7 04 cd 02
	00 00 00 08 00	 mov	 WORD PTR _m_IdtGate[ecx*8+2], 8

; 780  : 			m_IdtGate[m_IntHandlers[i].number].type			= m_IntHandlers[i].type;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00067	6b c0 07	 imul	 eax, 7
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0006d	6b c9 07	 imul	 ecx, 7
  00070	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  00077	66 8b 80 05 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+5]
  0007e	66 89 04 d5 04
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+4], ax

; 781  : 			m_IdtGate[m_IntHandlers[i].number].offset_high	= (WORD)(m_IntHandlers[i].offset >> 16);

  00086	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00089	6b c0 07	 imul	 eax, 7
  0008c	8b 88 01 00 00
	00		 mov	 ecx, DWORD PTR _m_IntHandlers[eax+1]
  00092	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00095	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00098	6b d2 07	 imul	 edx, 7
  0009b	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _m_IntHandlers[edx]
  000a2	66 89 0c c5 06
	00 00 00	 mov	 WORD PTR _m_IdtGate[eax*8+6], cx

; 782  : 			m_IdtGate[m_IntHandlers[i].number].offset_low	= (WORD)(m_IntHandlers[i].offset & 0xffff);

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ad	6b c0 07	 imul	 eax, 7
  000b0	8b 88 01 00 00
	00		 mov	 ecx, DWORD PTR _m_IntHandlers[eax+1]
  000b6	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000bc	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000bf	6b d2 07	 imul	 edx, 7
  000c2	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _m_IntHandlers[edx]
  000c9	66 89 0c c5 00
	00 00 00	 mov	 WORD PTR _m_IdtGate[eax*8], cx

; 783  : 		
; 784  : 	}

  000d1	e9 50 ff ff ff	 jmp	 $LN3@HalpStartI
$LN2@HalpStartI:

; 785  : 
; 786  : 	//IDTR 설정
; 787  : 	//IDT크기와 시작 Physical Address 설정 
; 788  : 	m_IdtrDesc.address	= (int)&m_IdtGate;

  000d6	c7 05 02 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_IdtrDesc+2, OFFSET _m_IdtGate

; 789  : 	m_IdtrDesc.size		= (WORD)(MAX_IDT*sizeof(IDT_GATE));

  000e0	66 c7 05 00 00
	00 00 00 02	 mov	 WORD PTR _m_IdtrDesc, 512 ; 00000200H

; 790  : 	//IDTR 포인터를 HalpEnableInterrupt로 전달 -> CPU가 IDT 테이블을 인식
; 791  : 	HalpEnableInterrupt((PIDTR_DESC)&m_IdtrDesc);

  000e9	68 00 00 00 00	 push	 OFFSET _m_IdtrDesc
  000ee	e8 00 00 00 00	 call	 _HalpEnableInterrupt
  000f3	83 c4 04	 add	 esp, 4

; 792  : 
; 793  : 	return TRUE;

  000f6	b8 01 00 00 00	 mov	 eax, 1

; 794  : }

  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
_HalpStartIntService ENDP
_TEXT	ENDS
END
