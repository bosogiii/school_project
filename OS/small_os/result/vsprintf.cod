; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\develop\MyoskOS\vsprintf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_vsprintf
; Function compile flags: /Odtp /ZI
; File c:\develop\myoskos\vsprintf.c
;	COMDAT _vsprintf
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 11   : 	return ffmt(buf, fmt, args);

  00009	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _ffmt
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12   : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_vsprintf ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _ffmt
_TEXT	SEGMENT
tv84 = -136						; size = 4
_width$ = -68						; size = 4
_flag$ = -64						; size = 4
_base$ = -60						; size = 4
_number$ = -56						; size = 4
_prefix$ = -49						; size = 1
_numptr$ = -48						; size = 4
_numtemp$ = -44						; size = 33
_temp$ = -5						; size = 1
_str$ = -4						; size = 4
_buf$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
_ffmt	PROC						; COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 16   : 	char *str, temp, numtemp[33], *numptr, prefix;
; 17   : 	unsigned int number, base, flag, width;
; 18   : 
; 19   : 	str = buf;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 20   : 	numtemp[32]=0;

  00012	c6 45 f4 00	 mov	 BYTE PTR _numtemp$[ebp+32], 0
  00016	eb 09		 jmp	 SHORT $LN33@ffmt
$LN32@ffmt:

; 21   : 
; 22   : 	for (; *fmt ; fmt++){

  00018	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 0c	 mov	 DWORD PTR _fmt$[ebp], eax
$LN33@ffmt:
  00021	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00024	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00027	85 c9		 test	 ecx, ecx
  00029	0f 84 73 02 00
	00		 je	 $LN31@ffmt

; 23   : 		if (*fmt != '%'){

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	83 f9 25	 cmp	 ecx, 37			; 00000025H
  00038	74 15		 je	 SHORT $LN30@ffmt

; 24   : 			*str = *fmt;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00040	8a 11		 mov	 dl, BYTE PTR [ecx]
  00042	88 10		 mov	 BYTE PTR [eax], dl

; 25   : 			++str;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 26   : 			continue;

  0004d	eb c9		 jmp	 SHORT $LN32@ffmt
$LN30@ffmt:

; 27   : 		}
; 28   : 
; 29   : 		fmt++;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00052	83 c0 01	 add	 eax, 1
  00055	89 45 0c	 mov	 DWORD PTR _fmt$[ebp], eax

; 30   : 		flag=0;

  00058	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0

; 31   : 		prefix= ' ';

  0005f	c6 45 cf 20	 mov	 BYTE PTR _prefix$[ebp], 32 ; 00000020H

; 32   : 		width=0;

  00063	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _width$[ebp], 0

; 33   : 
; 34   : 		if(*fmt == '0')

  0006a	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  0006d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00070	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00073	75 04		 jne	 SHORT $LN28@ffmt

; 35   : 			prefix='0';

  00075	c6 45 cf 30	 mov	 BYTE PTR _prefix$[ebp], 48 ; 00000030H
$LN28@ffmt:

; 36   : 
; 37   : 		while(*fmt >= '0' && *fmt <= '9') {

  00079	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  0007c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0007f	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00082	7c 29		 jl	 SHORT $LN27@ffmt
  00084	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  00087	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008a	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0008d	7f 1e		 jg	 SHORT $LN27@ffmt

; 38   : 			width=(width * 10) + (*(fmt++) - '0');

  0008f	8b 45 bc	 mov	 eax, DWORD PTR _width$[ebp]
  00092	6b c0 0a	 imul	 eax, 10			; 0000000aH
  00095	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  00098	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0009b	8d 44 10 d0	 lea	 eax, DWORD PTR [eax+edx-48]
  0009f	89 45 bc	 mov	 DWORD PTR _width$[ebp], eax
  000a2	8b 4d 0c	 mov	 ecx, DWORD PTR _fmt$[ebp]
  000a5	83 c1 01	 add	 ecx, 1
  000a8	89 4d 0c	 mov	 DWORD PTR _fmt$[ebp], ecx

; 39   : 		}

  000ab	eb cc		 jmp	 SHORT $LN28@ffmt
$LN27@ffmt:

; 40   : 
; 41   : 		switch(*fmt) {

  000ad	8b 45 0c	 mov	 eax, DWORD PTR _fmt$[ebp]
  000b0	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000b3	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv84[ebp], ecx
  000b9	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv84[ebp]
  000bf	83 ea 25	 sub	 edx, 37			; 00000025H
  000c2	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv84[ebp], edx
  000c8	83 bd 78 ff ff
	ff 53		 cmp	 DWORD PTR tv84[ebp], 83	; 00000053H
  000cf	0f 87 bf 00 00
	00		 ja	 $LN13@ffmt
  000d5	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv84[ebp]
  000db	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN36@ffmt[eax]
  000e2	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN37@ffmt[ecx*4]
$LN24@ffmt:

; 42   : 			case 'c':
; 43   : 				*str++ = va_arg(args, char);

  000e9	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  000ec	83 c0 04	 add	 eax, 4
  000ef	89 45 10	 mov	 DWORD PTR _args$[ebp], eax
  000f2	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  000f5	8b 55 10	 mov	 edx, DWORD PTR _args$[ebp]
  000f8	8a 42 fc	 mov	 al, BYTE PTR [edx-4]
  000fb	88 01		 mov	 BYTE PTR [ecx], al
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  00100	83 c1 01	 add	 ecx, 1
  00103	89 4d fc	 mov	 DWORD PTR _str$[ebp], ecx

; 44   : 				continue;

  00106	e9 0d ff ff ff	 jmp	 $LN32@ffmt
$LN23@ffmt:

; 45   : 			case 's':
; 46   : 				numptr = va_arg(args, char *);

  0010b	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  0010e	83 c0 04	 add	 eax, 4
  00111	89 45 10	 mov	 DWORD PTR _args$[ebp], eax
  00114	8b 4d 10	 mov	 ecx, DWORD PTR _args$[ebp]
  00117	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  0011a	89 55 d0	 mov	 DWORD PTR _numptr$[ebp], edx
$LN22@ffmt:

; 47   : 				while(*numptr != 0 )

  0011d	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  00120	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00123	85 c9		 test	 ecx, ecx
  00125	74 1e		 je	 SHORT $LN21@ffmt

; 48   : 					*str++ = *numptr++;

  00127	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0012a	8b 4d d0	 mov	 ecx, DWORD PTR _numptr$[ebp]
  0012d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0012f	88 10		 mov	 BYTE PTR [eax], dl
  00131	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  00134	83 c0 01	 add	 eax, 1
  00137	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax
  0013a	8b 4d d0	 mov	 ecx, DWORD PTR _numptr$[ebp]
  0013d	83 c1 01	 add	 ecx, 1
  00140	89 4d d0	 mov	 DWORD PTR _numptr$[ebp], ecx
  00143	eb d8		 jmp	 SHORT $LN22@ffmt
$LN21@ffmt:

; 49   : 				continue;

  00145	e9 ce fe ff ff	 jmp	 $LN32@ffmt
$LN20@ffmt:

; 50   : 			case '%':
; 51   : 				*str++ = '%';

  0014a	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0014d	c6 00 25	 mov	 BYTE PTR [eax], 37	; 00000025H
  00150	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  00153	83 c1 01	 add	 ecx, 1
  00156	89 4d fc	 mov	 DWORD PTR _str$[ebp], ecx

; 52   : 				continue;

  00159	e9 ba fe ff ff	 jmp	 $LN32@ffmt
$LN19@ffmt:

; 53   : 			case 'b':
; 54   : 				base = 2;

  0015e	c7 45 c4 02 00
	00 00		 mov	 DWORD PTR _base$[ebp], 2

; 55   : 				break;

  00165	eb 32		 jmp	 SHORT $LN25@ffmt
$LN18@ffmt:

; 56   : 			case 'd':   case 'i':
; 57   : 				flag |= SIGN;

  00167	8b 45 c0	 mov	 eax, DWORD PTR _flag$[ebp]
  0016a	83 c8 01	 or	 eax, 1
  0016d	89 45 c0	 mov	 DWORD PTR _flag$[ebp], eax
$LN17@ffmt:

; 58   : 			case 'u':
; 59   : 				base = 10;

  00170	c7 45 c4 0a 00
	00 00		 mov	 DWORD PTR _base$[ebp], 10 ; 0000000aH

; 60   : 				break;

  00177	eb 20		 jmp	 SHORT $LN25@ffmt
$LN16@ffmt:

; 61   : 			case 'o':
; 62   : 				base = 8;

  00179	c7 45 c4 08 00
	00 00		 mov	 DWORD PTR _base$[ebp], 8

; 63   : 				break;

  00180	eb 17		 jmp	 SHORT $LN25@ffmt
$LN15@ffmt:

; 64   : 			case 'X':
; 65   : 				flag |= LARGE;

  00182	8b 45 c0	 mov	 eax, DWORD PTR _flag$[ebp]
  00185	83 c8 02	 or	 eax, 2
  00188	89 45 c0	 mov	 DWORD PTR _flag$[ebp], eax
$LN14@ffmt:

; 66   : 			case 'x':
; 67   : 				base = 16;

  0018b	c7 45 c4 10 00
	00 00		 mov	 DWORD PTR _base$[ebp], 16 ; 00000010H

; 68   : 				break;

  00192	eb 05		 jmp	 SHORT $LN25@ffmt
$LN13@ffmt:

; 69   : 			default:
; 70   : 				continue;

  00194	e9 7f fe ff ff	 jmp	 $LN32@ffmt
$LN25@ffmt:

; 71   : 		}
; 72   : 
; 73   : 		numptr = &numtemp[31];

  00199	8d 45 f3	 lea	 eax, DWORD PTR _numtemp$[ebp+31]
  0019c	89 45 d0	 mov	 DWORD PTR _numptr$[ebp], eax

; 74   : 		number = va_arg(args, unsigned int);

  0019f	8b 45 10	 mov	 eax, DWORD PTR _args$[ebp]
  001a2	83 c0 04	 add	 eax, 4
  001a5	89 45 10	 mov	 DWORD PTR _args$[ebp], eax
  001a8	8b 4d 10	 mov	 ecx, DWORD PTR _args$[ebp]
  001ab	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  001ae	89 55 c8	 mov	 DWORD PTR _number$[ebp], edx

; 75   : 
; 76   : 		if( (flag&SIGN) && (number&0x80000000) ) {

  001b1	8b 45 c0	 mov	 eax, DWORD PTR _flag$[ebp]
  001b4	83 e0 01	 and	 eax, 1
  001b7	74 24		 je	 SHORT $LN11@ffmt
  001b9	8b 45 c8	 mov	 eax, DWORD PTR _number$[ebp]
  001bc	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001c1	74 1a		 je	 SHORT $LN11@ffmt

; 77   : 			number = ~number + 1;

  001c3	8b 45 c8	 mov	 eax, DWORD PTR _number$[ebp]
  001c6	f7 d0		 not	 eax
  001c8	83 c0 01	 add	 eax, 1
  001cb	89 45 c8	 mov	 DWORD PTR _number$[ebp], eax

; 78   : 			*str++ = '-';

  001ce	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  001d1	c6 00 2d	 mov	 BYTE PTR [eax], 45	; 0000002dH
  001d4	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  001d7	83 c1 01	 add	 ecx, 1
  001da	89 4d fc	 mov	 DWORD PTR _str$[ebp], ecx
$LN11@ffmt:

; 79   : 		}
; 80   : 
; 81   : 		do {
; 82   : 			temp = number%base;

  001dd	8b 45 c8	 mov	 eax, DWORD PTR _number$[ebp]
  001e0	33 d2		 xor	 edx, edx
  001e2	f7 75 c4	 div	 DWORD PTR _base$[ebp]
  001e5	88 55 fb	 mov	 BYTE PTR _temp$[ebp], dl

; 83   : 			if(temp > 0) {

  001e8	0f be 45 fb	 movsx	 eax, BYTE PTR _temp$[ebp]
  001ec	85 c0		 test	 eax, eax
  001ee	7e 1d		 jle	 SHORT $LN8@ffmt

; 84   : 				temp += ((flag & LARGE ? 'A' : 'a') - 10);

  001f0	8b 45 c0	 mov	 eax, DWORD PTR _flag$[ebp]
  001f3	83 e0 02	 and	 eax, 2
  001f6	f7 d8		 neg	 eax
  001f8	1b c0		 sbb	 eax, eax
  001fa	83 e0 e0	 and	 eax, -32		; ffffffe0H
  001fd	83 c0 61	 add	 eax, 97			; 00000061H
  00200	0f be 4d fb	 movsx	 ecx, BYTE PTR _temp$[ebp]
  00204	8d 54 01 f6	 lea	 edx, DWORD PTR [ecx+eax-10]
  00208	88 55 fb	 mov	 BYTE PTR _temp$[ebp], dl

; 85   : 			} else {

  0020b	eb 0a		 jmp	 SHORT $LN7@ffmt
$LN8@ffmt:

; 86   : 				temp += '0';

  0020d	0f be 45 fb	 movsx	 eax, BYTE PTR _temp$[ebp]
  00211	83 c0 30	 add	 eax, 48			; 00000030H
  00214	88 45 fb	 mov	 BYTE PTR _temp$[ebp], al
$LN7@ffmt:

; 87   : 			}
; 88   : 			*numptr-- = temp;

  00217	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  0021a	8a 4d fb	 mov	 cl, BYTE PTR _temp$[ebp]
  0021d	88 08		 mov	 BYTE PTR [eax], cl
  0021f	8b 55 d0	 mov	 edx, DWORD PTR _numptr$[ebp]
  00222	83 ea 01	 sub	 edx, 1
  00225	89 55 d0	 mov	 DWORD PTR _numptr$[ebp], edx

; 89   : 			if(width > 0) width--;

  00228	83 7d bc 00	 cmp	 DWORD PTR _width$[ebp], 0
  0022c	76 09		 jbe	 SHORT $LN10@ffmt
  0022e	8b 45 bc	 mov	 eax, DWORD PTR _width$[ebp]
  00231	83 e8 01	 sub	 eax, 1
  00234	89 45 bc	 mov	 DWORD PTR _width$[ebp], eax
$LN10@ffmt:

; 90   : 		} while(number/=base);

  00237	8b 45 c8	 mov	 eax, DWORD PTR _number$[ebp]
  0023a	33 d2		 xor	 edx, edx
  0023c	f7 75 c4	 div	 DWORD PTR _base$[ebp]
  0023f	89 45 c8	 mov	 DWORD PTR _number$[ebp], eax
  00242	83 7d c8 00	 cmp	 DWORD PTR _number$[ebp], 0
  00246	75 95		 jne	 SHORT $LN11@ffmt

; 91   : 
; 92   : 		if(width > 0) {

  00248	83 7d bc 00	 cmp	 DWORD PTR _width$[ebp], 0
  0024c	76 23		 jbe	 SHORT $LN2@ffmt
$LN4@ffmt:

; 93   : 			while(width-- != 0)

  0024e	8b 45 bc	 mov	 eax, DWORD PTR _width$[ebp]
  00251	8b 4d bc	 mov	 ecx, DWORD PTR _width$[ebp]
  00254	83 e9 01	 sub	 ecx, 1
  00257	89 4d bc	 mov	 DWORD PTR _width$[ebp], ecx
  0025a	85 c0		 test	 eax, eax
  0025c	74 13		 je	 SHORT $LN2@ffmt

; 94   : 				*numptr-- = prefix;

  0025e	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  00261	8a 4d cf	 mov	 cl, BYTE PTR _prefix$[ebp]
  00264	88 08		 mov	 BYTE PTR [eax], cl
  00266	8b 55 d0	 mov	 edx, DWORD PTR _numptr$[ebp]
  00269	83 ea 01	 sub	 edx, 1
  0026c	89 55 d0	 mov	 DWORD PTR _numptr$[ebp], edx
  0026f	eb dd		 jmp	 SHORT $LN4@ffmt
$LN2@ffmt:

; 95   : 		}
; 96   : 		while(temp = *(++numptr)) {

  00271	8b 45 d0	 mov	 eax, DWORD PTR _numptr$[ebp]
  00274	83 c0 01	 add	 eax, 1
  00277	89 45 d0	 mov	 DWORD PTR _numptr$[ebp], eax
  0027a	8b 4d d0	 mov	 ecx, DWORD PTR _numptr$[ebp]
  0027d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0027f	88 55 fb	 mov	 BYTE PTR _temp$[ebp], dl
  00282	0f be 45 fb	 movsx	 eax, BYTE PTR _temp$[ebp]
  00286	85 c0		 test	 eax, eax
  00288	74 13		 je	 SHORT $LN1@ffmt

; 97   : 			*str++ = temp;

  0028a	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0028d	8a 4d fb	 mov	 cl, BYTE PTR _temp$[ebp]
  00290	88 08		 mov	 BYTE PTR [eax], cl
  00292	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  00295	83 c2 01	 add	 edx, 1
  00298	89 55 fc	 mov	 DWORD PTR _str$[ebp], edx

; 98   : 		}

  0029b	eb d4		 jmp	 SHORT $LN2@ffmt
$LN1@ffmt:

; 99   : 	}

  0029d	e9 76 fd ff ff	 jmp	 $LN32@ffmt
$LN31@ffmt:

; 100  : 	*str = 0;

  002a2	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  002a5	c6 00 00	 mov	 BYTE PTR [eax], 0

; 101  : 
; 102  : 	return (int)(str-buf+1);

  002a8	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  002ab	2b 45 08	 sub	 eax, DWORD PTR _buf$[ebp]
  002ae	83 c0 01	 add	 eax, 1

; 103  : }

  002b1	5f		 pop	 edi
  002b2	5e		 pop	 esi
  002b3	5b		 pop	 ebx
  002b4	8b e5		 mov	 esp, ebp
  002b6	5d		 pop	 ebp
  002b7	c3		 ret	 0
$LN37@ffmt:
  002b8	00 00 00 00	 DD	 $LN20@ffmt
  002bc	00 00 00 00	 DD	 $LN15@ffmt
  002c0	00 00 00 00	 DD	 $LN19@ffmt
  002c4	00 00 00 00	 DD	 $LN24@ffmt
  002c8	00 00 00 00	 DD	 $LN18@ffmt
  002cc	00 00 00 00	 DD	 $LN16@ffmt
  002d0	00 00 00 00	 DD	 $LN23@ffmt
  002d4	00 00 00 00	 DD	 $LN17@ffmt
  002d8	00 00 00 00	 DD	 $LN14@ffmt
  002dc	00 00 00 00	 DD	 $LN13@ffmt
$LN36@ffmt:
  002e0	00		 DB	 0
  002e1	09		 DB	 9
  002e2	09		 DB	 9
  002e3	09		 DB	 9
  002e4	09		 DB	 9
  002e5	09		 DB	 9
  002e6	09		 DB	 9
  002e7	09		 DB	 9
  002e8	09		 DB	 9
  002e9	09		 DB	 9
  002ea	09		 DB	 9
  002eb	09		 DB	 9
  002ec	09		 DB	 9
  002ed	09		 DB	 9
  002ee	09		 DB	 9
  002ef	09		 DB	 9
  002f0	09		 DB	 9
  002f1	09		 DB	 9
  002f2	09		 DB	 9
  002f3	09		 DB	 9
  002f4	09		 DB	 9
  002f5	09		 DB	 9
  002f6	09		 DB	 9
  002f7	09		 DB	 9
  002f8	09		 DB	 9
  002f9	09		 DB	 9
  002fa	09		 DB	 9
  002fb	09		 DB	 9
  002fc	09		 DB	 9
  002fd	09		 DB	 9
  002fe	09		 DB	 9
  002ff	09		 DB	 9
  00300	09		 DB	 9
  00301	09		 DB	 9
  00302	09		 DB	 9
  00303	09		 DB	 9
  00304	09		 DB	 9
  00305	09		 DB	 9
  00306	09		 DB	 9
  00307	09		 DB	 9
  00308	09		 DB	 9
  00309	09		 DB	 9
  0030a	09		 DB	 9
  0030b	09		 DB	 9
  0030c	09		 DB	 9
  0030d	09		 DB	 9
  0030e	09		 DB	 9
  0030f	09		 DB	 9
  00310	09		 DB	 9
  00311	09		 DB	 9
  00312	09		 DB	 9
  00313	01		 DB	 1
  00314	09		 DB	 9
  00315	09		 DB	 9
  00316	09		 DB	 9
  00317	09		 DB	 9
  00318	09		 DB	 9
  00319	09		 DB	 9
  0031a	09		 DB	 9
  0031b	09		 DB	 9
  0031c	09		 DB	 9
  0031d	02		 DB	 2
  0031e	03		 DB	 3
  0031f	04		 DB	 4
  00320	09		 DB	 9
  00321	09		 DB	 9
  00322	09		 DB	 9
  00323	09		 DB	 9
  00324	04		 DB	 4
  00325	09		 DB	 9
  00326	09		 DB	 9
  00327	09		 DB	 9
  00328	09		 DB	 9
  00329	09		 DB	 9
  0032a	05		 DB	 5
  0032b	09		 DB	 9
  0032c	09		 DB	 9
  0032d	09		 DB	 9
  0032e	06		 DB	 6
  0032f	09		 DB	 9
  00330	07		 DB	 7
  00331	09		 DB	 9
  00332	09		 DB	 9
  00333	08		 DB	 8
_ffmt	ENDP
_TEXT	ENDS
END
