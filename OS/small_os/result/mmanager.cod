; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	c:\develop\MyoskOS\mmanager.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@ ; `string'
PUBLIC	??_C@_0CN@PMHMBCPL@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0CL@NCIHNJEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@ ; `string'
PUBLIC	_MmkInitializeMemoryManager
EXTRN	_CrtPrintf:PROC
;	COMDAT ??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@
; File c:\develop\myoskos\mmanager.c
CONST	SEGMENT
??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@ DB 'Memo'
	DB	'ry Manager is initialized!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PMHMBCPL@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CN@PMHMBCPL@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@ DB 'MmpCreat'
	DB	'eMemPoolBlk() returned an error . ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NCIHNJEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@
CONST	SEGMENT
??_C@_0CL@NCIHNJEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@ DB 'MmpCheck'
	DB	'MemorySize() returned an error. ', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _MmkInitializeMemoryManager
_TEXT	SEGMENT
_MmkInitializeMemoryManager PROC			; COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 37   : 	if(!MmpCheckMemorySize()) {

  00009	e8 00 00 00 00	 call	 _MmpCheckMemorySize
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN2@MmkInitial

; 38   : 		DbgPrint("MmpCheckMemorySize() returned an error. \r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NCIHNJEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 39   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 2c		 jmp	 SHORT $LN3@MmkInitial
$LN2@MmkInitial:

; 40   : 	}
; 41   : 
; 42   : 	if(!MmpCreateMemPoolBlk()){

  00023	e8 00 00 00 00	 call	 _MmpCreateMemPoolBlk
  00028	85 c0		 test	 eax, eax
  0002a	75 11		 jne	 SHORT $LN1@MmkInitial

; 43   : 		DbgPrint("MmpCreateMemPoolBlk() returned an error . \r\n");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@PMHMBCPL@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@
  00031	e8 00 00 00 00	 call	 _CrtPrintf
  00036	83 c4 04	 add	 esp, 4

; 44   : 		return FALSE;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 12		 jmp	 SHORT $LN3@MmkInitial
$LN1@MmkInitial:

; 45   : 	}
; 46   : 	DbgPrint("Memory Manager is initialized!!\r\n");

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@
  00042	e8 00 00 00 00	 call	 _CrtPrintf
  00047	83 c4 04	 add	 esp, 4

; 47   : 
; 48   : 	return TRUE;

  0004a	b8 01 00 00 00	 mov	 eax, 1
$LN3@MmkInitial:

; 49   : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_MmkInitializeMemoryManager ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_MemSize DD	01H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _MmpCheckMemorySize
_TEXT	SEGMENT
_tmp$ = -12						; size = 4
_pAddr$ = -8						; size = 4
_bResult$ = -4						; size = 4
_MmpCheckMemorySize PROC				; COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 52   : 	BOOL bResult;
; 53   : 	DWORD *pAddr = (DWORD *)0x00000000, tmp;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pAddr$[ebp], 0
$LN3@MmpCheckMe:

; 54   : 
; 55   : 	while(1) {

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 33		 je	 SHORT $LN2@MmpCheckMe

; 56   : 		pAddr += (4*1024*1024);

  00019	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  0001c	05 00 00 00 01	 add	 eax, 16777216		; 01000000H
  00021	89 45 f8	 mov	 DWORD PTR _pAddr$[ebp], eax

; 57   : 		tmp = *pAddr;

  00024	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f4	 mov	 DWORD PTR _tmp$[ebp], ecx

; 58   : 		*pAddr = 0x11223344;

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  0002f	c7 00 44 33 22
	11		 mov	 DWORD PTR [eax], 287454020 ; 11223344H

; 59   : 		if(*pAddr != 0x11223344)

  00035	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00038	81 38 44 33 22
	11		 cmp	 DWORD PTR [eax], 287454020 ; 11223344H
  0003e	74 02		 je	 SHORT $LN1@MmpCheckMe

; 60   : 			break;

  00040	eb 0a		 jmp	 SHORT $LN2@MmpCheckMe
$LN1@MmpCheckMe:

; 61   : 
; 62   : 		*pAddr = tmp;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00048	89 08		 mov	 DWORD PTR [eax], ecx

; 63   : 	}

  0004a	eb c4		 jmp	 SHORT $LN3@MmpCheckMe
$LN2@MmpCheckMe:

; 64   : 
; 65   : 	ENTER_CRITICAL_SECTION();

  0004c	9c		 pushfd
  0004d	fa		 cli

; 66   : 
; 67   : 	m_MemSize = (DWORD)pAddr;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00051	a3 00 00 00 00	 mov	 DWORD PTR _m_MemSize, eax

; 68   : 	bResult = (m_MemSize < MEMORY_POOL_START_ADDRESS+(1*1024*1024) ? FALSE : TRUE);

  00056	81 3d 00 00 00
	00 00 00 30 00	 cmp	 DWORD PTR _m_MemSize, 3145728 ; 00300000H
  00060	1b c0		 sbb	 eax, eax
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 fc	 mov	 DWORD PTR _bResult$[ebp], eax

; 69   : 	EXIT_CRITICAL_SECTION();

  00068	9d		 popfd

; 70   : 
; 71   : 	return bResult;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 72   : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_MmpCheckMemorySize ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_MemBlkManager DB 014H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _MmpCreateMemPoolBlk
_TEXT	SEGMENT
_pCur$ = -32						; size = 4
_pPrev$ = -28						; size = 4
_pPoolEntry$ = -24					; size = 4
_i$ = -20						; size = 4
_dwBlksOfDescs$ = -16					; size = 4
_dwBlksOfAllocatableMem$ = -12				; size = 4
_dwBlksOfUsableMem$ = -8				; size = 4
_dwUsableMemSize$ = -4					; size = 4
_MmpCreateMemPoolBlk PROC				; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 76   : 	DWORD dwUsableMemSize;
; 77   : 	DWORD dwBlksOfUsableMem;
; 78   : 	DWORD dwBlksOfAllocatableMem;
; 79   : 	DWORD dwBlksOfDescs;
; 80   : 	DWORD i;
; 81   : 
; 82   : 	int *pPoolEntry;
; 83   : 	MEM_BLK_DESC *pPrev, *pCur;
; 84   : 
; 85   : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 86   : 	dwUsableMemSize = m_MemSize - MEMORY_POOL_START_ADDRESS;

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_MemSize
  00010	2d 00 00 20 00	 sub	 eax, 2097152		; 00200000H
  00015	89 45 fc	 mov	 DWORD PTR _dwUsableMemSize$[ebp], eax

; 87   : EXIT_CRITICAL_SECTION();

  00018	9d		 popfd

; 88   : 
; 89   : 	dwBlksOfUsableMem	= MmpGetRequiredBlocksFromBytes(dwUsableMemSize);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _dwUsableMemSize$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 f8	 mov	 DWORD PTR _dwBlksOfUsableMem$[ebp], eax

; 90   : 	dwBlksOfDescs		= MmpGetRequiredBlocksFromBytes(dwBlksOfUsableMem*sizeof(MEM_BLK_DESC));

  00028	8b 45 f8	 mov	 eax, DWORD PTR _dwBlksOfUsableMem$[ebp]
  0002b	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 f0	 mov	 DWORD PTR _dwBlksOfDescs$[ebp], eax

; 91   : 
; 92   : 	dwBlksOfAllocatableMem = dwBlksOfUsableMem-dwBlksOfDescs;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _dwBlksOfUsableMem$[ebp]
  0003d	2b 45 f0	 sub	 eax, DWORD PTR _dwBlksOfDescs$[ebp]
  00040	89 45 f4	 mov	 DWORD PTR _dwBlksOfAllocatableMem$[ebp], eax

; 93   : 
; 94   : 	dwBlksOfDescs	= MmpGetRequiredBlocksFromBytes(dwBlksOfAllocatableMem*sizeof(MEM_BLK_DESC));

  00043	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  00046	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  0004f	83 c4 04	 add	 esp, 4
  00052	89 45 f0	 mov	 DWORD PTR _dwBlksOfDescs$[ebp], eax

; 95   : 
; 96   : 	pPoolEntry	= (int*)(MEMORY_POOL_START_ADDRESS+dwBlksOfDescs*MEM_BLK_SIZE);

  00055	8b 45 f0	 mov	 eax, DWORD PTR _dwBlksOfDescs$[ebp]
  00058	c1 e0 09	 shl	 eax, 9
  0005b	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  00060	89 45 e8	 mov	 DWORD PTR _pPoolEntry$[ebp], eax

; 97   : 
; 98   : ENTER_CRITICAL_SECTION();

  00063	9c		 pushfd
  00064	fa		 cli

; 99   : 	m_MemBlkManager.nBlocks	= dwBlksOfAllocatableMem;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  00068	a3 00 00 00 00	 mov	 DWORD PTR _m_MemBlkManager, eax

; 100  : 	m_MemBlkManager.nUsedBlocks = 0;

  0006d	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+4, 0

; 101  : 	m_MemBlkManager.nFreeBlocks = dwBlksOfAllocatableMem;

  00077	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  0007a	a3 08 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+8, eax

; 102  : 	m_MemBlkManager.pDescEntry = (MEM_BLK_DESC*)MEMORY_POOL_START_ADDRESS;

  0007f	c7 05 0c 00 00
	00 00 00 20 00	 mov	 DWORD PTR _m_MemBlkManager+12, 2097152 ; 00200000H

; 103  : 	m_MemBlkManager.pPoolEntry = pPoolEntry;

  00089	8b 45 e8	 mov	 eax, DWORD PTR _pPoolEntry$[ebp]
  0008c	a3 10 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+16, eax

; 104  : 
; 105  : 	pPrev = m_MemBlkManager.pDescEntry;

  00091	a1 0c 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+12
  00096	89 45 e4	 mov	 DWORD PTR _pPrev$[ebp], eax

; 106  : 	pPrev->status=MEM_BLK_FREE;

  00099	8b 45 e4	 mov	 eax, DWORD PTR _pPrev$[ebp]
  0009c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 107  : 
; 108  : 	for(i=1; i<dwBlksOfAllocatableMem; i++)

  000a2	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000a9	eb 09		 jmp	 SHORT $LN3@MmpCreateM
$LN2@MmpCreateM:
  000ab	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN3@MmpCreateM:
  000b4	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000b7	3b 45 f4	 cmp	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  000ba	73 32		 jae	 SHORT $LN1@MmpCreateM

; 109  : 	{
; 110  : 		pCur = (MEM_BLK_DESC*)(MEMORY_POOL_START_ADDRESS+sizeof(MEM_BLK_DESC)*i);

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000bf	6b c0 0c	 imul	 eax, 12			; 0000000cH
  000c2	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  000c7	89 45 e0	 mov	 DWORD PTR _pCur$[ebp], eax

; 111  : 		pCur->status = MEM_BLK_FREE;

  000ca	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 112  : 		pCur->block_size =0;

  000d3	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000d6	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 113  : 		pPrev->pNext = pCur;

  000dd	8b 45 e4	 mov	 eax, DWORD PTR _pPrev$[ebp]
  000e0	8b 4d e0	 mov	 ecx, DWORD PTR _pCur$[ebp]
  000e3	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 114  : 		pPrev=pCur;

  000e6	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000e9	89 45 e4	 mov	 DWORD PTR _pPrev$[ebp], eax

; 115  : 	}

  000ec	eb bd		 jmp	 SHORT $LN2@MmpCreateM
$LN1@MmpCreateM:

; 116  : 	pCur->pNext = NULL;

  000ee	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000f1	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 117  : EXIT_CRITICAL_SECTION();

  000f8	9d		 popfd

; 118  : 	return TRUE;

  000f9	b8 01 00 00 00	 mov	 eax, 1

; 119  : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_MmpCreateMemPoolBlk ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _MmpGetRequiredBlocksFromBytes
_TEXT	SEGMENT
_dwBlocks$ = -4						; size = 4
_bytes$ = 8						; size = 4
_MmpGetRequiredBlocksFromBytes PROC			; COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 123  : 	DWORD dwBlocks = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwBlocks$[ebp], 0

; 124  : 
; 125  : 	dwBlocks = bytes/MEM_BLK_SIZE;

  00010	8b 45 08	 mov	 eax, DWORD PTR _bytes$[ebp]
  00013	c1 e8 09	 shr	 eax, 9
  00016	89 45 fc	 mov	 DWORD PTR _dwBlocks$[ebp], eax

; 126  : 	if(bytes % MEM_BLK_SIZE)

  00019	8b 45 08	 mov	 eax, DWORD PTR _bytes$[ebp]
  0001c	33 d2		 xor	 edx, edx
  0001e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00023	f7 f1		 div	 ecx
  00025	85 d2		 test	 edx, edx
  00027	74 09		 je	 SHORT $LN1@MmpGetRequ

; 127  : 		dwBlocks++;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _dwBlocks$[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 fc	 mov	 DWORD PTR _dwBlocks$[ebp], eax
$LN1@MmpGetRequ:

; 128  : 
; 129  : 	return dwBlocks;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _dwBlocks$[ebp]

; 130  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_MmpGetRequiredBlocksFromBytes ENDP
_TEXT	ENDS
END
